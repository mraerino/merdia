<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title></title>
  <meta name="description" content="" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
</head>

<body>
  <button id="start">Start!</button>
  <script type="module">
    import { JSONParser } from "https://unpkg.com/@streamparser/json@0.0.13/dist/mjs/index.js";

    // from https://itnext.io/understand-async-iterators-665259680044
    const makeStream = function () {
      const pullQueue = []
      const pushQueue = []
      let done = false
      const pushValue = async (args) => {
        if (pullQueue.length !== 0) {
          const resolver = pullQueue.shift()
          resolver(...args)
        } else {
          pushQueue.push(args)
        }
      }

      const pullValue = () => {
        return new Promise((resolve) => {
          if (pushQueue.length !== 0) {
            const args = pushQueue.shift()
            resolve(...args)
          } else {
            pullQueue.push(resolve)
          }
        })
      }

      return {
        [Symbol.asyncIterator]() {
          return this
        },
        next: () => {
          if (pushQueue.length > 0) {
            return {
              done: false,
              value: Promise.resolve(...pushQueue.shift()),
            }
          }
          if (done) {
            return { done, value: undefined }
          }
          return { done: false, value: pullValue() }
        },
        return: () => {
          done = true
          return { done }
        },
        throw: (error) => {
          done = true
          return {
            done,
            value: Promise.reject(error)
          }
        },
        push: (...args) => {
          pushValue(args)
        }
      }
    }

    async function* parseJsonObjectStream(stream, handler) {
      const values = makeStream();

      const parser = new JSONParser({ paths: ["$"], separator: "" });
      parser.onValue = values.push
      parser.onEnd = values.return

      let done = false;
      const reader = stream.getReader();
      (async () => {
        while (true) {
          const { done, value } = await reader.read();
          if (value) {
            parser.write(value);
          }
          if (done) {
            parser.end();
            return
          }
        }
      })()

      for await (const item of values) {
        yield (await item).value
      }
    }

    const displayMediaOptions = {
      video: {
        cursor: "always",
      },
      audio: false
    };

    const connectWebRTC = async () => {
      const peerConn = new RTCPeerConnection({
        iceServers: [],
      });

      // events
      peerConn.addEventListener("iceconnectionstatechange", () =>
        console.debug("ice connection state change:", peerConn.iceConnectionState)
      );
      peerConn.addEventListener("connectionstatechange", () => {
        console.debug("connection state change:", peerConn.connectionState)
      })
      peerConn.addEventListener("icecandidateerror", ({ address, url, errorText }) => {
        console.error("ice candidate error:", { address, url, errorText })
      })
      peerConn.addEventListener("signalingstatechange", () => {
        console.debug("signaling state changed:", peerConn.signalingState)
      })

      const gatherPromise = new Promise((resolve) => {
        const candidates = [];
        const cb = ({ candidate }) => {
          if (candidate === null) {
            peerConn.removeEventListener("icecandidate", cb)
            resolve(candidates)
          } else {
            candidates.push(candidate)
            console.debug("got ice candidate", { candidate })
          }
        }
        peerConn.addEventListener("icecandidate", cb)
      })

      const stream = await navigator.mediaDevices.getDisplayMedia(displayMediaOptions);
      peerConn.addStream(stream);

      const initialOffer = await peerConn.createOffer();
      await peerConn.setLocalDescription(initialOffer);

      await gatherPromise;

      const resp = await fetch("/screen_share", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ offer: peerConn.localDescription.sdp })
      });

      if (!resp.ok) {
        throw new Error(`Invalid response: ${resp.status}, ${await resp.text()}`)
      }

      const signalingStream = parseJsonObjectStream(resp.body);
      const { done, value } = await signalingStream.next();
      if (value.answer) {
        console.debug("setting remote description", value.answer)
        await peerConn.setRemoteDescription(value.answer)
      } else {
        console.error("invalid json item when expecting SDP answer", value)
      }

      if (!done) {
        // add ice candidates in the background
        (async () => {
          for await (const value of signalingStream) {
            const resolved = await value;
            if (resolved.candidate) {
              console.debug("adding candidate", resolved.candidate)
              await peerConn.addIceCandidate(resolved.candidate)
            } else {
              console.error("invalid json item", resolved)
            }
          }
        })()
      }

      return peerConn;
    }

    document.getElementById("start").addEventListener("click", () => {
      connectWebRTC()
    })
  </script>
</body>

</html>